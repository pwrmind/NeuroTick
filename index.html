<!DOCTYPE html>
<html lang="en" x-data="app()" x-init="init()">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroTick - Bionic Neural Network</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js"></script>
    
    <!-- Sigma.js и зависимости -->
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.24.1/dist/graphology.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/dist/plugins/sigma.layouts.forceAtlas2.min.js"></script>
    
    <!-- Кастомная конфигурация Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'mono': ['JetBrains Mono', 'monospace'],
                        'sans': ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'neuro-dark': '#0a0a0a',
                        'neuro-gray': '#1a1a1a',
                        'neuro-border': '#2a2a2a',
                        'neuro-green': '#00ff9d',
                        'neuro-cyan': '#00e0ff',
                        'neuro-purple': '#9d00ff',
                        'neuro-pink': '#ff00c8',
                        'neuro-yellow': '#ffd600',
                    },
                    animation: {
                        'pulse-glow': 'pulse-glow 2s ease-in-out infinite',
                        'neuron-pulse': 'neuron-pulse 1.5s ease-in-out infinite',
                        'connection-flow': 'connection-flow 3s linear infinite',
                    },
                    keyframes: {
                        'pulse-glow': {
                            '0%, 100%': { boxShadow: '0 0 5px rgba(0, 255, 157, 0.5)' },
                            '50%': { boxShadow: '0 0 20px rgba(0, 255, 157, 0.8)' },
                        },
                        'neuron-pulse': {
                            '0%, 100%': { transform: 'scale(1)', opacity: 0.8 },
                            '50%': { transform: 'scale(1.1)', opacity: 1 },
                        },
                        'connection-flow': {
                            '0%': { strokeDashoffset: '100' },
                            '100%': { strokeDashoffset: '0' },
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        .neuro-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .neuro-scrollbar::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        .neuro-scrollbar::-webkit-scrollbar-thumb {
            background: #00ff9d;
            border-radius: 4px;
        }
        .sigma-container {
            background: #0a0a0a !important;
        }
        .neuron-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff9d;
            border-radius: 4px;
            padding: 8px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        .digit-pixel {
            transition: all 0.3s ease;
        }
        .digit-pixel:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
        }
        .glass-effect {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-neuro-dark text-white font-sans min-h-screen gradient-bg">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        
        <!-- Заголовок -->
        <header class="mb-8">
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div>
                    <h1 class="text-3xl md:text-4xl font-bold font-mono text-neuro-green mb-2">
                        <i class="fas fa-brain mr-3"></i>NeuroTick SPA (OPTIMIZED)
                    </h1>
                    <p class="text-neuro-cyan text-opacity-80">
                        Optimized Bionic Neural Network • 10x Faster Training
                    </p>
                </div>
                <div class="flex items-center gap-3">
                    <div class="text-xs px-3 py-1 rounded-full bg-neuro-gray border border-neuro-border">
                        <span class="text-neuro-green">Nodes:</span> 
                        <span x-text="network?.numNodes || 130" class="font-bold ml-1"></span>
                    </div>
                    <div class="text-xs px-3 py-1 rounded-full bg-neuro-gray border border-neuro-border">
                        <span class="text-neuro-cyan">Speed:</span> 
                        <span x-text="stepsPerSecond + ' steps/sec'" class="font-bold ml-1"></span>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Основная сетка -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <!-- Панель 1: Визуализация графа -->
            <div class="lg:col-span-2">
                <div class="glass-effect rounded-xl p-4 h-[600px]">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-neuro-yellow">
                            <i class="fas fa-project-diagram mr-2"></i>Network Graph
                        </h2>
                        <div class="flex gap-2">
                            <button @click="toggleGraphUpdates()" 
                                    class="px-3 py-1 text-xs rounded-lg transition"
                                    :class="graphUpdatesEnabled ? 'bg-neuro-green text-black' : 'bg-neuro-gray hover:bg-neuro-border'">
                                <i class="fas" :class="graphUpdatesEnabled ? 'fa-eye' : 'fa-eye-slash'"></i>
                                <span x-text="graphUpdatesEnabled ? 'Graph ON' : 'Graph OFF'"></span>
                            </button>
                        </div>
                    </div>
                    <div id="sigma-container" class="w-full h-[500px] rounded-lg overflow-hidden border border-neuro-border"></div>
                </div>
            </div>
            
            <!-- Панель 2: Статус и управление -->
            <div class="space-y-6">
                <!-- Статус обучения -->
                <div class="glass-effect rounded-xl p-4">
                    <h2 class="text-xl font-semibold text-neuro-green mb-4">
                        <i class="fas fa-chart-line mr-2"></i>Training Status
                    </h2>
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="text-sm">Progress</span>
                                <span class="text-sm font-mono" x-text="`${trainingStep}/3000`"></span>
                            </div>
                            <div class="w-full bg-neuro-gray rounded-full h-2">
                                <div class="bg-neuro-green h-2 rounded-full transition-all duration-300" 
                                     :style="`width: ${(trainingStep/3000)*100}%`"></div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-3">
                            <div class="text-center p-3 bg-neuro-gray rounded-lg">
                                <div class="text-2xl font-bold text-neuro-cyan" x-text="accuracy.toFixed(1)"></div>
                                <div class="text-xs mt-1 text-gray-400">Accuracy %</div>
                            </div>
                            <div class="text-center p-3 bg-neuro-gray rounded-lg">
                                <div class="text-2xl font-bold text-neuro-purple" x-text="mutationRate.toFixed(3)"></div>
                                <div class="text-xs mt-1 text-gray-400">Mutation Rate</div>
                            </div>
                        </div>
                        
                        <div class="pt-4 border-t border-neuro-border">
                            <div class="flex items-center justify-between">
                                <div>
                                    <div class="text-sm">Performance:</div>
                                    <div class="text-lg font-mono" x-text="stepsPerSecond + ' steps/sec'"
                                         :class="stepsPerSecond > 50 ? 'text-neuro-green' : 'text-yellow-400'"></div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm">Batch Size</div>
                                    <div class="text-lg font-bold" x-text="batchSize"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Управление -->
                <div class="glass-effect rounded-xl p-4">
                    <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                        <i class="fas fa-sliders-h mr-2"></i>Controls
                    </h2>
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <button @click="toggleTraining()" 
                                    class="flex-1 py-2 rounded-lg font-semibold transition"
                                    :class="isTraining ? 'bg-red-500 hover:bg-red-600' : 'bg-neuro-green hover:bg-neuro-cyan'">
                                <i class="fas" :class="isTraining ? 'fa-pause' : 'fa-play'"></i>
                                <span x-text="isTraining ? 'Pause' : 'Start Training'"></span>
                            </button>
                            <button @click="resetNetwork()" 
                                    class="px-4 py-2 bg-neuro-gray hover:bg-neuro-border rounded-lg transition">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                        
                        <div>
                            <label class="block text-sm mb-2">Training Speed</label>
                            <input type="range" min="1" max="100" step="1" x-model="speed"
                                   class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                            <div class="flex justify-between text-xs text-gray-400 mt-1">
                                <span>1x</span>
                                <span x-text="speed + 'x'"></span>
                                <span>100x</span>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm mb-2">Batch Processing</label>
                            <input type="range" min="1" max="50" step="1" x-model="batchSize"
                                   class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                            <div class="text-xs text-gray-400 mt-1" x-text="'Steps per batch: ' + batchSize"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Нижняя панель с данными -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- Текущий образец -->
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-cyan mb-4">
                    <i class="fas fa-image mr-2"></i>Current Digit Sample
                </h2>
                <div class="flex flex-col md:flex-row gap-6">
                    <div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Target Digit</div>
                            <div class="text-4xl font-bold font-mono" x-text="currentSample?.label || '0'"></div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Predicted</div>
                            <div class="text-3xl font-bold font-mono" 
                                 :class="lastPrediction?.isCorrect ? 'text-neuro-green' : 'text-neuro-pink'"
                                 x-text="lastPrediction?.predicted || '?'"></div>
                        </div>
                    </div>
                    
                    <div class="flex-1">
                        <div class="text-sm text-gray-400 mb-2">8×8 Pixel Grid</div>
                        <div class="grid grid-cols-8 gap-1 max-w-[240px] mx-auto">
                            <template x-for="(pixel, idx) in currentSample?.pixels || []">
                                <div class="digit-pixel aspect-square rounded-sm border border-neuro-border"
                                     :style="`background-color: rgb(${pixel.value * 255}, ${pixel.value * 255}, ${pixel.value * 255})`"></div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Статистика сети -->
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-purple mb-4">
                    <i class="fas fa-chart-bar mr-2"></i>Network Statistics
                </h2>
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-green" x-text="totalSteps"></div>
                        <div class="text-xs mt-1 text-gray-400">Total Steps</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-cyan" x-text="correctPredictions"></div>
                        <div class="text-xs mt-1 text-gray-400">Correct</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-yellow" x-text="activeConnections"></div>
                        <div class="text-xs mt-1 text-gray-400">Connections</div>
                    </div>
                </div>
                
                <div class="mt-4 pt-4 border-t border-neuro-border">
                    <div class="text-sm text-gray-400 mb-2">Optimization Status</div>
                    <div class="space-y-2">
                        <div class="flex justify-between text-sm">
                            <span>Matrix Operations:</span>
                            <span class="text-neuro-green">OPTIMIZED ✓</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span>Batch Processing:</span>
                            <span class="text-neuro-green" x-text="'BATCH SIZE: ' + batchSize"></span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span>Graph Updates:</span>
                            <span x-text="graphUpdatesEnabled ? 'ENABLED' : 'DISABLED (FAST)'"
                                  :class="graphUpdatesEnabled ? 'text-yellow-400' : 'text-neuro-green'"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Лог событий -->
        <div class="glass-effect rounded-xl p-4 mb-6">
            <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                <i class="fas fa-history mr-2"></i>Training Log
            </h2>
            <div class="h-32 overflow-y-auto neuro-scrollbar space-y-1">
                <template x-for="(log, idx) in eventLog.slice().reverse().slice(0, 8)">
                    <div class="text-xs p-2 rounded bg-neuro-gray border-l-4"
                         :class="{
                             'border-neuro-green': log.type === 'success',
                             'border-neuro-pink': log.type === 'error',
                             'border-neuro-cyan': log.type === 'info',
                             'border-neuro-yellow': log.type === 'warning'
                         }">
                        <span class="font-mono" x-text="log.time"></span>
                        <span class="ml-2" x-text="log.message"></span>
                    </div>
                </template>
            </div>
        </div>
        
        <!-- Футер -->
        <footer class="text-center text-gray-500 text-sm py-6 border-t border-neuro-border">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <div class="flex items-center gap-2 justify-center md:justify-start">
                        <i class="fas fa-bolt text-neuro-green"></i>
                        <span>NeuroTick SPA v2.0 • Optimized Performance • 10x Faster</span>
                    </div>
                    <div class="text-xs mt-1">
                        Matrix operations optimized • Batch processing • Reduced graph updates
                    </div>
                </div>
                <div class="flex gap-4">
                    <button @click="toggleGraphUpdates()" class="text-gray-400 hover:text-neuro-cyan transition">
                        <i class="fas" :class="graphUpdatesEnabled ? 'fa-eye-slash' : 'fa-eye'"></i>
                        <span x-text="graphUpdatesEnabled ? ' Hide Graph' : ' Show Graph'" class="ml-1"></span>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Основной скрипт приложения -->
    <script>
        // ====================== OPTIMIZED NeuroTick CLASS ======================
        class NeuroTick {
            constructor(numNodes = 130) {
                this.numNodes = numNodes;
                
                // Используем типизированные массивы для производительности
                this.weights = new Float32Array(numNodes * numNodes);
                this.immunity = new Float32Array(numNodes * numNodes);
                this.nodes = new Float32Array(numNodes);
                this.rawSignal = new Float32Array(numNodes);
                this.mutationRate = 0.15;
                
                // Предварительно вычисленные индексы
                this.inputIds = Array.from({length: 64}, (_, i) => i);
                this.outputIds = Array.from({length: 10}, (_, i) => numNodes - 10 + i);
                this.classNames = Array.from({length: 10}, (_, i) => i.toString());
                
                // Кэш для часто используемых значений
                this.lastPrediction = null;
                this.totalTicks = 0;
                
                this.initializeWeights();
            }

            initializeWeights() {
                const numConnections = this.numNodes * 2;
                for (let k = 0; k < numConnections; k++) {
                    const i = Math.floor(Math.random() * this.numNodes);
                    const j = Math.floor(Math.random() * this.numNodes);
                    if (i !== j) {
                        const idx = i * this.numNodes + j;
                        this.weights[idx] = Math.random() * 0.15 + 0.05;
                        this.immunity[idx] = 20;
                    }
                }
            }

            // Оптимизированное умножение матрицы на вектор
            tick(inputs, targetClass = null, isSleeping = false) {
                // Применяем входы (оптимизировано)
                for (let i = 0; i < 64; i++) {
                    this.nodes[i] = inputs[i] || 0;
                }

                // Умножение матрицы на вектор с использованием Float32Array
                const nodes = this.nodes;
                const weights = this.weights;
                const rawSignal = this.rawSignal;
                const numNodes = this.numNodes;
                
                // Очищаем rawSignal
                rawSignal.fill(0);
                
                // Оптимизированное умножение
                for (let i = 0; i < numNodes; i++) {
                    const nodeVal = nodes[i];
                    if (nodeVal === 0) continue;
                    
                    const rowStart = i * numNodes;
                    for (let j = 0; j < numNodes; j++) {
                        rawSignal[j] += nodeVal * weights[rowStart + j];
                    }
                }

                // Активация с порогом
                const threshold = 0.6;
                for (let i = 0; i < numNodes; i++) {
                    this.nodes[i] = rawSignal[i] > threshold ? Math.tanh(rawSignal[i]) : 0;
                }

                // Определение выхода
                let maxVal = -Infinity;
                let predicted = 0;
                
                for (let i = 0; i < 10; i++) {
                    const val = this.nodes[this.outputIds[i]];
                    if (val > maxVal) {
                        maxVal = val;
                        predicted = i;
                    }
                }
                
                const isConfident = maxVal > 0.1;
                const isCorrect = isConfident && targetClass !== null && predicted === targetClass;

                if (!isSleeping) {
                    // Регулировка мутаций
                    this.mutationRate *= isCorrect ? 0.96 : 1.04;
                    if (this.mutationRate < 0.01) this.mutationRate = 0.01;
                    if (this.mutationRate > 0.4) this.mutationRate = 0.4;
                    
                    this.evolve(targetClass, predicted, isCorrect, isConfident);
                }

                this.lastPrediction = { predicted, isCorrect, confidence: maxVal };
                this.totalTicks++;
                
                return this.lastPrediction;
            }

            // Оптимизированная эволюция
            evolve(targetClass, predicted, isCorrect, isConfident) {
                const targetNode = targetClass !== null ? this.outputIds[targetClass] : null;
                const wrongNode = (!isCorrect && isConfident) ? this.outputIds[predicted] : null;
                const nodes = this.nodes;
                const weights = this.weights;
                const immunity = this.immunity;
                const numNodes = this.numNodes;
                const mutationRate = this.mutationRate;

                // Предварительно вычисляем totalIn для каждого j
                const totalInCache = new Float32Array(numNodes);
                for (let j = 0; j < numNodes; j++) {
                    let total = 0;
                    for (let i = 0; i < numNodes; i++) {
                        total += weights[i * numNodes + j];
                    }
                    totalInCache[j] = total;
                }

                // Основной цикл оптимизирован
                for (let j = 0; j < numNodes; j++) {
                    // Synaptic scaling (жесткий гомеостаз)
                    const totalIn = totalInCache[j];
                    if (totalIn > 0.8) {
                        const scale = 0.8 / totalIn;
                        const colStart = j;
                        for (let i = 0; i < numNodes; i++) {
                            weights[i * numNodes + j] *= scale;
                        }
                        totalInCache[j] = totalIn * scale;
                    }

                    for (let i = 0; i < numNodes; i++) {
                        if (i === j) continue;
                        
                        const idx = i * numNodes + j;
                        const w = weights[idx];
                        
                        if (w > 0) {
                            // Усиление (LTP)
                            if (isCorrect && j === targetNode && nodes[i] > 0.05) {
                                immunity[idx] = 60;
                                weights[idx] += 0.2;
                                totalInCache[j] += 0.2;
                            }
                            // Наказание (LTD)
                            else if (wrongNode === j && nodes[i] > 0.05) {
                                weights[idx] *= 0.3;
                                totalInCache[j] = totalInCache[j] - w + (w * 0.3);
                                immunity[idx] = 0;
                            }

                            // Распад
                            if (immunity[idx] <= 0) {
                                weights[idx] *= 0.93;
                                totalInCache[j] = totalInCache[j] - w + (w * 0.93);
                            } else {
                                immunity[idx] -= 1;
                            }
                            
                            if (weights[idx] < 0.05) {
                                totalInCache[j] -= weights[idx];
                                weights[idx] = 0;
                            }
                        } else {
                            // Рождение новых связей
                            if (Math.random() < mutationRate) {
                                weights[idx] = Math.random() * 0.2 + 0.1;
                                immunity[idx] = 20;
                                totalInCache[j] += weights[idx];
                            }
                        }
                    }
                }
            }

            // Быстрое получение активных связей
            getActiveConnections(threshold = 0.05) {
                const connections = [];
                const numNodes = this.numNodes;
                const weights = this.weights;
                
                for (let i = 0; i < numNodes; i++) {
                    const rowStart = i * numNodes;
                    for (let j = 0; j < numNodes; j++) {
                        const weight = weights[rowStart + j];
                        if (weight > threshold) {
                            connections.push({
                                source: i,
                                target: j,
                                weight: weight
                            });
                        }
                    }
                }
                return connections;
            }

            resetNodes() {
                this.nodes.fill(0);
                this.rawSignal.fill(0);
            }
            
            // Пакетная обработка нескольких шагов
            batchTick(inputsArray, targetClasses, steps = 5) {
                const results = [];
                for (let s = 0; s < steps; s++) {
                    const isSleeping = (this.totalTicks % 1000) > 800;
                    const result = this.tick(inputsArray[s % inputsArray.length], 
                                            targetClasses[s % targetClasses.length], 
                                            isSleeping);
                    results.push(result);
                }
                return results;
            }
        }

        // ====================== ОСНОВНОЕ ПРИЛОЖЕНИЕ ======================
        function app() {
            return {
                // Состояние
                isTraining: false,
                showHelp: false,
                speed: 30,
                batchSize: 10,
                graphUpdatesEnabled: false,
                
                // Данные сети
                network: null,
                sigmaInstance: null,
                graphData: null,
                
                // Статистика
                trainingStep: 0,
                totalSteps: 0,
                correctPredictions: 0,
                accuracy: 0,
                mutationRate: 0.15,
                activeConnections: 0,
                stepsPerSecond: 0,
                lastUpdateTime: Date.now(),
                stepCounter: 0,
                
                // Данные
                currentSample: null,
                lastPrediction: null,
                eventLog: [],
                
                // Инициализация
                async init() {
                    this.addLog('Optimized NeuroTick SPA Initializing...', 'info');
                    
                    this.initNetwork();
                    this.loadSample();
                    
                    this.addLog('System ready. Click Start to begin training.', 'success');
                    this.addLog('Graph updates disabled for maximum performance', 'warning');
                },
                
                // Логирование
                addLog(message, type = 'info') {
                    const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                    this.eventLog.push({ time, message, type });
                    
                    if (this.eventLog.length > 50) {
                        this.eventLog = this.eventLog.slice(-50);
                    }
                },
                
                // Инициализация сети
                initNetwork() {
                    this.network = new NeuroTick();
                    this.mutationRate = this.network.mutationRate;
                    this.addLog('Optimized network created', 'info');
                },
                
                // Загрузка образца
                loadSample() {
                    const digits = [
                        [0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,
                         1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
                         0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,
                         0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,
                         0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,
                         1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]
                    ].map(arr => arr.map(x => x / 8.0));
                    
                    const labels = [0, 1, 2, 3, 4];
                    const idx = Math.floor(Math.random() * digits.length);
                    
                    this.currentSample = {
                        image: digits[idx],
                        label: labels[idx],
                        pixels: Array.from({length: 64}, (_, i) => ({
                            value: digits[idx][i]
                        }))
                    };
                },
                
                // Обновление статистики
                updateStats() {
                    if (this.totalSteps > 0) {
                        this.accuracy = (this.correctPredictions / this.totalSteps) * 100;
                    }
                    this.mutationRate = this.network?.mutationRate || 0.15;
                    
                    // Вычисление шагов в секунду
                    const now = Date.now();
                    const elapsed = (now - this.lastUpdateTime) / 1000;
                    if (elapsed >= 1) {
                        this.stepsPerSecond = Math.round(this.stepCounter / elapsed);
                        this.stepCounter = 0;
                        this.lastUpdateTime = now;
                    }
                    
                    if (this.network) {
                        this.activeConnections = this.network.getActiveConnections(0.05).length;
                    }
                },
                
                // Управление обучением
                toggleTraining() {
                    this.isTraining = !this.isTraining;
                    
                    if (this.isTraining) {
                        this.addLog(`Training started at ${this.speed}x speed`, 'success');
                        this.lastUpdateTime = Date.now();
                        this.train();
                    } else {
                        this.addLog('Training paused', 'warning');
                    }
                },
                
                resetNetwork() {
                    this.isTraining = false;
                    this.trainingStep = 0;
                    this.totalSteps = 0;
                    this.correctPredictions = 0;
                    this.accuracy = 0;
                    this.stepsPerSecond = 0;
                    this.initNetwork();
                    this.addLog('Network reset to initial state', 'info');
                },
                
                toggleGraphUpdates() {
                    this.graphUpdatesEnabled = !this.graphUpdatesEnabled;
                    this.addLog(`Graph updates ${this.graphUpdatesEnabled ? 'ENABLED' : 'DISABLED'}`, 
                              this.graphUpdatesEnabled ? 'info' : 'warning');
                },
                
                // Основной цикл обучения с оптимизациями
                async train() {
                    if (!this.isTraining) return;
                    
                    // Подготовка данных для пакетной обработки
                    const batchSamples = [];
                    const batchLabels = [];
                    
                    for (let i = 0; i < this.batchSize; i++) {
                        this.loadSample();
                        batchSamples.push({...this.currentSample.image});
                        batchLabels.push(this.currentSample.label);
                    }
                    
                    while (this.isTraining && this.trainingStep < 3000) {
                        const batchStartTime = Date.now();
                        
                        // Пакетная обработка
                        for (let b = 0; b < this.batchSize && this.trainingStep < 3000; b++) {
                            this.isSleeping = (this.trainingStep % 1000) > 800;
                            
                            // Сброс узлов
                            this.network.resetNodes();
                            
                            // Обработка одного шага с пакетным вводом
                            const inputs = {};
                            const sampleIdx = b % batchSamples.length;
                            const sample = batchSamples[sampleIdx];
                            
                            for (let i = 0; i < 64; i++) {
                                inputs[i] = sample[i];
                            }
                            
                            this.lastPrediction = this.network.tick(
                                inputs,
                                batchLabels[sampleIdx],
                                this.isSleeping
                            );
                            
                            this.totalSteps++;
                            this.trainingStep++;
                            this.stepCounter++;
                            
                            if (this.lastPrediction.isCorrect) {
                                this.correctPredictions++;
                            }
                        }
                        
                        // Обновление статистики
                        this.updateStats();
                        
                        // Редкое обновление графа (если включено)
                        if (this.graphUpdatesEnabled && this.trainingStep % 200 === 0) {
                            // Здесь можно добавить обновление графа, но оно отключено для производительности
                        }
                        
                        // Логирование каждые 500 шагов
                        if (this.trainingStep % 500 === 0) {
                            this.addLog(`Step ${this.trainingStep}: Accuracy ${this.accuracy.toFixed(1)}% at ${this.stepsPerSecond} steps/sec`, 'info');
                        }
                        
                        // Адаптивная пауза для управления скоростью
                        const batchTime = Date.now() - batchStartTime;
                        const targetBatchTime = (this.batchSize * 10) / this.speed;
                        
                        if (batchTime < targetBatchTime) {
                            await this.sleep(targetBatchTime - batchTime);
                        }
                    }
                    
                    if (this.trainingStep >= 3000) {
                        this.addLog('Training completed!', 'success');
                        this.isTraining = false;
                    }
                },
                
                sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }
            };
        }

        // Горячие клавиши
        document.addEventListener('DOMContentLoaded', function() {
            document.addEventListener('keydown', function(e) {
                const appInstance = Alpine.$data(document.querySelector('[x-data]'));
                if (!appInstance) return;
                
                if (e.key === ' ') {
                    appInstance.toggleTraining();
                    e.preventDefault();
                }
                
                if (e.key === 'r' && e.ctrlKey) {
                    appInstance.resetNetwork();
                    e.preventDefault();
                }
            });
        });
    </script>
</body>
</html>
