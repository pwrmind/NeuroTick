<!DOCTYPE html>
<html lang="en" x-data="app()" x-init="init()">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroTick - Bionic Neural Network</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js"></script>
    
    <!-- Sigma.js –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –í–ï–†–°–ò–ò) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.24.0/graphology.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://unpkg.com/graphology-layout-forceatlas2@0.10.0"></script>
    
    <!-- –ö–∞—Å—Ç–æ–º–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'mono': ['JetBrains Mono', 'monospace'],
                        'sans': ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'neuro-dark': '#0a0a0a',
                        'neuro-gray': '#1a1a1a',
                        'neuro-border': '#2a2a2a',
                        'neuro-green': '#00ff9d',
                        'neuro-cyan': '#00e0ff',
                        'neuro-purple': '#9d00ff',
                        'neuro-pink': '#ff00c8',
                        'neuro-yellow': '#ffd600',
                    },
                    animation: {
                        'pulse-glow': 'pulse-glow 2s ease-in-out infinite',
                        'neuron-pulse': 'neuron-pulse 1.5s ease-in-out infinite',
                        'connection-flow': 'connection-flow 3s linear infinite',
                    },
                    keyframes: {
                        'pulse-glow': {
                            '0%, 100%': { boxShadow: '0 0 5px rgba(0, 255, 157, 0.5)' },
                            '50%': { boxShadow: '0 0 20px rgba(0, 255, 157, 0.8)' },
                        },
                        'neuron-pulse': {
                            '0%, 100%': { transform: 'scale(1)', opacity: 0.8 },
                            '50%': { transform: 'scale(1.1)', opacity: 1 },
                        },
                        'connection-flow': {
                            '0%': { strokeDashoffset: '100' },
                            '100%': { strokeDashoffset: '0' },
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* –ö–∞—Å—Ç–æ–º–Ω—ã–µ —Å—Ç–∏–ª–∏ */
        .neuro-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .neuro-scrollbar::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        .neuro-scrollbar::-webkit-scrollbar-thumb {
            background: #00ff9d;
            border-radius: 4px;
        }
        .sigma-container {
            background: #0a0a0a !important;
        }
        .neuron-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff9d;
            border-radius: 4px;
            padding: 8px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        .digit-pixel {
            transition: all 0.3s ease;
        }
        .digit-pixel:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
        }
        .glass-effect {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-neuro-dark text-white font-sans min-h-screen gradient-bg">
    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä -->
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        
        <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
        <header class="mb-8">
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div>
                    <h1 class="text-3xl md:text-4xl font-bold font-mono text-neuro-green mb-2">
                        <i class="fas fa-brain mr-3"></i>NeuroTick SPA
                    </h1>
                    <p class="text-neuro-cyan text-opacity-80">
                        Bionic Neural Network Visualizer ‚Ä¢ Interactive Graph Learning
                    </p>
                </div>
                <div class="flex items-center gap-3">
                    <div class="text-xs px-3 py-1 rounded-full bg-neuro-gray border border-neuro-border">
                        <span class="text-neuro-green">Active Nodes:</span> 
                        <span x-text="network?.nodes?.length || 0" class="font-bold ml-1"></span>
                    </div>
                    <div class="text-xs px-3 py-1 rounded-full bg-neuro-gray border border-neuro-border">
                        <span class="text-neuro-cyan">Connections:</span> 
                        <span x-text="activeConnections" class="font-bold ml-1"></span>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- –û—Å–Ω–æ–≤–Ω–∞—è —Å–µ—Ç–∫–∞ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <!-- –ü–∞–Ω–µ–ª—å 1: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞ -->
            <div class="lg:col-span-2">
                <div class="glass-effect rounded-xl p-4 h-[600px]">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-neuro-yellow">
                            <i class="fas fa-project-diagram mr-2"></i>Network Graph
                        </h2>
                        <div class="flex gap-2">
                            <button @click="toggleLayout()" class="px-3 py-1 text-xs bg-neuro-gray hover:bg-neuro-border rounded-lg transition">
                                <i class="fas fa-sitemap mr-1"></i>Layout
                            </button>
                            <button @click="resetView()" class="px-3 py-1 text-xs bg-neuro-gray hover:bg-neuro-border rounded-lg transition">
                                <i class="fas fa-crosshairs mr-1"></i>Reset View
                            </button>
                        </div>
                    </div>
                    <div id="sigma-container" class="w-full h-[500px] rounded-lg overflow-hidden border border-neuro-border"></div>
                </div>
            </div>
            
            <!-- –ü–∞–Ω–µ–ª—å 2: –°—Ç–∞—Ç—É—Å –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
            <div class="space-y-6">
                <!-- –°—Ç–∞—Ç—É—Å –æ–±—É—á–µ–Ω–∏—è -->
                <div class="glass-effect rounded-xl p-4">
                    <h2 class="text-xl font-semibold text-neuro-green mb-4">
                        <i class="fas fa-chart-line mr-2"></i>Training Status
                    </h2>
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="text-sm">Progress</span>
                                <span class="text-sm font-mono" x-text="`${trainingStep}/3000`"></span>
                            </div>
                            <div class="w-full bg-neuro-gray rounded-full h-2">
                                <div class="bg-neuro-green h-2 rounded-full transition-all duration-300" 
                                     :style="`width: ${(trainingStep/3000)*100}%`"></div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-3">
                            <div class="text-center p-3 bg-neuro-gray rounded-lg">
                                <div class="text-2xl font-bold text-neuro-cyan" x-text="accuracy.toFixed(1)"></div>
                                <div class="text-xs mt-1 text-gray-400">Accuracy %</div>
                            </div>
                            <div class="text-center p-3 bg-neuro-gray rounded-lg">
                                <div class="text-2xl font-bold text-neuro-purple" x-text="mutationRate.toFixed(3)"></div>
                                <div class="text-xs mt-1 text-gray-400">Mutation Rate</div>
                            </div>
                        </div>
                        
                        <div class="pt-4 border-t border-neuro-border">
                            <div class="flex items-center justify-between">
                                <div>
                                    <div class="text-sm">Current Phase:</div>
                                    <div class="text-lg font-mono" x-text="isSleeping ? 'SLEEP üí§' : 'LEARNING üß†'"
                                         :class="isSleeping ? 'text-neuro-cyan' : 'text-neuro-green'"></div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm">Active Connections</div>
                                    <div class="text-lg font-bold" x-text="activeConnections"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
                <div class="glass-effect rounded-xl p-4">
                    <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                        <i class="fas fa-sliders-h mr-2"></i>Controls
                    </h2>
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <button @click="toggleTraining()" 
                                    class="flex-1 py-2 rounded-lg font-semibold transition"
                                    :class="isTraining ? 'bg-red-500 hover:bg-red-600' : 'bg-neuro-green hover:bg-neuro-cyan'">
                                <i class="fas" :class="isTraining ? 'fa-pause' : 'fa-play'"></i>
                                <span x-text="isTraining ? 'Pause' : 'Start'"></span>
                            </button>
                            <button @click="resetNetwork()" 
                                    class="px-4 py-2 bg-neuro-gray hover:bg-neuro-border rounded-lg transition">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                        
                        <div>
                            <label class="block text-sm mb-2">Network Speed</label>
                            <input type="range" min="1" max="10" step="1" x-model="speed"
                                   class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                            <div class="flex justify-between text-xs text-gray-400 mt-1">
                                <span>Slow</span>
                                <span x-text="speed + 'x'"></span>
                                <span>Fast</span>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm mb-2">Connection Threshold</label>
                            <input type="range" min="0" max="0.5" step="0.01" x-model="connectionThreshold"
                                   @input="updateGraph()"
                                   class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                            <div class="text-xs text-gray-400 mt-1" x-text="'Show > ' + connectionThreshold.toFixed(2)"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å —Å –¥–∞–Ω–Ω—ã–º–∏ -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- –¢–µ–∫—É—â–∏–π –æ–±—Ä–∞–∑–µ—Ü -->
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-cyan mb-4">
                    <i class="fas fa-image mr-2"></i>Current Digit Sample
                </h2>
                <div class="flex flex-col md:flex-row gap-6">
                    <div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Target Digit</div>
                            <div class="text-4xl font-bold font-mono" x-text="currentSample?.label || '0'"></div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Predicted</div>
                            <div class="text-3xl font-bold font-mono" 
                                 :class="prediction?.isCorrect ? 'text-neuro-green' : 'text-neuro-pink'"
                                 x-text="prediction?.predicted || '?'"></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">Confidence</div>
                            <div class="text-2xl font-mono" 
                                 :class="prediction?.confidence > 0.5 ? 'text-neuro-green' : 'text-yellow-400'"
                                 x-text="prediction?.confidence ? (prediction.confidence * 100).toFixed(1) + '%' : '0%'"></div>
                        </div>
                    </div>
                    
                    <div class="flex-1">
                        <div class="text-sm text-gray-400 mb-2">8√ó8 Pixel Grid</div>
                        <div class="grid grid-cols-8 gap-1 max-w-[240px] mx-auto">
                            <template x-for="(pixel, idx) in currentSample?.pixels || []">
                                <div class="digit-pixel aspect-square rounded-sm border border-neuro-border"
                                     :style="`background-color: rgb(${pixel.value * 255}, ${pixel.value * 255}, ${pixel.value * 255})`"
                                     :title="`Value: ${pixel.value?.toFixed(2) || 0}`"></div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ç–∏ -->
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-purple mb-4">
                    <i class="fas fa-chart-bar mr-2"></i>Network Statistics
                </h2>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-green" x-text="totalSteps"></div>
                        <div class="text-xs mt-1 text-gray-400">Total Steps</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-cyan" x-text="correctPredictions"></div>
                        <div class="text-xs mt-1 text-gray-400">Correct</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-yellow" x-text="network?.numNodes || 130"></div>
                        <div class="text-xs mt-1 text-gray-400">Total Nodes</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-pink" x-text="inputNodes"></div>
                        <div class="text-xs mt-1 text-gray-400">Input Neurons</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-purple" x-text="hiddenNodes"></div>
                        <div class="text-xs mt-1 text-gray-400">Hidden Neurons</div>
                    </div>
                    <div class="text-center p-3 bg-neuro-gray rounded-lg">
                        <div class="text-2xl font-bold text-neuro-green" x-text="outputNodes"></div>
                        <div class="text-xs mt-1 text-gray-400">Output Neurons</div>
                    </div>
                </div>
                
                <div class="mt-4 pt-4 border-t border-neuro-border">
                    <div class="text-sm text-gray-400 mb-2">Node Activity</div>
                    <div class="flex items-center gap-2">
                        <template x-for="n in 20">
                            <div class="flex-1 h-6 bg-neuro-gray rounded overflow-hidden">
                                <div class="h-full bg-neuro-green transition-all duration-300"
                                     :style="`width: ${Math.random() * 100}%`"></div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- –õ–æ–≥ —Å–æ–±—ã—Ç–∏–π -->
        <div class="glass-effect rounded-xl p-4 mb-6">
            <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                <i class="fas fa-history mr-2"></i>Event Log
            </h2>
            <div class="h-40 overflow-y-auto neuro-scrollbar space-y-2">
                <template x-for="(log, idx) in eventLog.slice().reverse().slice(0, 10)">
                    <div class="text-sm p-2 rounded bg-neuro-gray border-l-4"
                         :class="{
                             'border-neuro-green': log.type === 'success',
                             'border-neuro-pink': log.type === 'error',
                             'border-neuro-cyan': log.type === 'info',
                             'border-neuro-yellow': log.type === 'warning'
                         }">
                        <span class="font-mono text-xs text-gray-400" x-text="log.time"></span>
                        <span class="ml-2" x-text="log.message"></span>
                    </div>
                </template>
            </div>
        </div>
        
        <!-- –§—É—Ç–µ—Ä -->
        <footer class="text-center text-gray-500 text-sm py-6 border-t border-neuro-border">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <div class="flex items-center gap-2 justify-center md:justify-start">
                        <i class="fas fa-code text-neuro-green"></i>
                        <span>NeuroTick SPA v1.0 ‚Ä¢ Interactive Neural Network Visualization</span>
                    </div>
                    <div class="text-xs mt-1">
                        Powered by Alpine.js, sigma.js, Tailwind CSS
                    </div>
                </div>
                <div class="flex gap-4">
                    <button @click="exportNetwork()" class="text-gray-400 hover:text-neuro-green transition">
                        <i class="fas fa-download mr-1"></i>Export
                    </button>
                    <button @click="toggleTheme()" class="text-gray-400 hover:text-neuro-cyan transition">
                        <i class="fas fa-moon mr-1"></i>Theme
                    </button>
                    <button @click="showHelp = true" class="text-gray-400 hover:text-neuro-yellow transition">
                        <i class="fas fa-question-circle mr-1"></i>Help
                    </button>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–º–æ—â–∏ -->
    <template x-if="showHelp">
        <div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div class="bg-neuro-gray rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto neuro-scrollbar">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-2xl font-bold text-neuro-green">
                            <i class="fas fa-question-circle mr-2"></i>NeuroTick SPA Guide
                        </h3>
                        <button @click="showHelp = false" class="text-gray-400 hover:text-white">
                            <i class="fas fa-times text-2xl"></i>
                        </button>
                    </div>
                    
                    <div class="space-y-4">
                        <div class="p-4 bg-neuro-dark rounded-lg">
                            <h4 class="font-semibold text-neuro-cyan mb-2">What is NeuroTick?</h4>
                            <p class="text-gray-300">
                                NeuroTick is a bionic neural network that evolves through simulated biological processes 
                                like synaptic plasticity, mutation, and homeostasis. Unlike traditional neural networks, 
                                it doesn't use backpropagation.
                            </p>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="p-4 bg-neuro-dark rounded-lg">
                                <h4 class="font-semibold text-neuro-yellow mb-2">Controls</h4>
                                <ul class="text-gray-300 space-y-2">
                                    <li><i class="fas fa-play text-neuro-green mr-2"></i>Start/Pause training</li>
                                    <li><i class="fas fa-redo text-gray-400 mr-2"></i>Reset network</li>
                                    <li><i class="fas fa-sitemap text-neuro-cyan mr-2"></i>Change graph layout</li>
                                    <li><i class="fas fa-sliders-h text-neuro-purple mr-2"></i>Adjust parameters</li>
                                </ul>
                            </div>
                            
                            <div class="p-4 bg-neuro-dark rounded-lg">
                                <h4 class="font-semibold text-neuro-pink mb-2">Visualization</h4>
                                <ul class="text-gray-300 space-y-2">
                                    <li><span class="text-neuro-green">Green nodes</span>: Input neurons (pixels)</li>
                                    <li><span class="text-neuro-cyan">Cyan nodes</span>: Hidden neurons</li>
                                    <li><span class="text-neuro-purple">Purple nodes</span>: Output neurons (digits)</li>
                                    <li><span class="text-neuro-yellow">Line thickness</span>: Connection strength</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>
    
    <!-- –û—Å–Ω–æ–≤–Ω–æ–π —Å–∫—Ä–∏–ø—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô) -->
    <script>
        // –ö–ª–∞—Å—Å –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏ NeuroTick (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        class NeuroTick {
            constructor(numNodes = 130) {
                this.numNodes = numNodes;
                this.weights = Array(numNodes).fill().map(() => Array(numNodes).fill(0));
                this.immunity = Array(numNodes).fill().map(() => Array(numNodes).fill(0));
                this.nodes = Array(numNodes).fill(0);
                this.mutationRate = 0.15;
                
                this.inputIds = Array.from({length: 64}, (_, i) => i);
                this.outputIds = Array.from({length: 10}, (_, i) => numNodes - 10 + i);
                this.classNames = Array.from({length: 10}, (_, i) => i.toString());
                
                this.initializeWeights();
            }

            initializeWeights() {
                for (let k = 0; k < this.numNodes * 2; k++) {
                    const i = Math.floor(Math.random() * this.numNodes);
                    const j = Math.floor(Math.random() * this.numNodes);
                    if (i !== j) {
                        this.weights[i][j] = Math.random() * 0.15 + 0.05;
                        this.immunity[i][j] = 20;
                    }
                }
            }

            tick(inputs, targetClass = null, isSleeping = false) {
                Object.entries(inputs).forEach(([idx, val]) => {
                    this.nodes[parseInt(idx)] = val;
                });

                const rawSignal = new Array(this.numNodes).fill(0);
                for (let j = 0; j < this.numNodes; j++) {
                    let sum = 0;
                    for (let i = 0; i < this.numNodes; i++) {
                        sum += this.nodes[i] * this.weights[i][j];
                    }
                    rawSignal[j] = sum;
                }

                for (let i = 0; i < this.numNodes; i++) {
                    this.nodes[i] = rawSignal[i] > 0.6 ? Math.tanh(rawSignal[i]) : 0;
                }

                const outputVals = this.outputIds.map(id => this.nodes[id]);
                const maxVal = Math.max(...outputVals);
                const predicted = outputVals.indexOf(maxVal);
                const isConfident = maxVal > 0.1;
                const isCorrect = isConfident && targetClass !== null && predicted === targetClass;

                if (!isSleeping) {
                    this.mutationRate *= isCorrect ? 0.96 : 1.04;
                    this.mutationRate = Math.max(0.01, Math.min(0.4, this.mutationRate));
                    this.evolve(targetClass, predicted, isCorrect, isConfident);
                }

                return {
                    predicted,
                    isCorrect,
                    confidence: maxVal,
                    outputValues: outputVals
                };
            }

            evolve(targetClass, predicted, isCorrect, isConfident) {
                const targetNode = targetClass !== null ? this.outputIds[targetClass] : null;
                const wrongNode = (!isCorrect && isConfident) ? this.outputIds[predicted] : null;

                for (let j = 0; j < this.numNodes; j++) {
                    let totalIn = 0;
                    for (let i = 0; i < this.numNodes; i++) {
                        totalIn += this.weights[i][j];
                    }
                    
                    if (totalIn > 0.8) {
                        const scale = 0.8 / totalIn;
                        for (let i = 0; i < this.numNodes; i++) {
                            this.weights[i][j] *= scale;
                        }
                    }

                    for (let i = 0; i < this.numNodes; i++) {
                        if (i === j) continue;
                        
                        const w = this.weights[i][j];
                        
                        if (w > 0) {
                            if (isCorrect && j === targetNode && this.nodes[i] > 0.05) {
                                this.immunity[i][j] = 60;
                                this.weights[i][j] += 0.2;
                            }
                            else if (wrongNode === j && this.nodes[i] > 0.05) {
                                this.weights[i][j] *= 0.3;
                                this.immunity[i][j] = 0;
                            }

                            if (this.immunity[i][j] <= 0) {
                                this.weights[i][j] *= 0.93;
                            } else {
                                this.immunity[i][j] -= 1;
                            }

                            if (this.weights[i][j] < 0.05) {
                                this.weights[i][j] = 0;
                            }
                        } else {
                            if (Math.random() < this.mutationRate) {
                                this.weights[i][j] = Math.random() * 0.2 + 0.1;
                                this.immunity[i][j] = 20;
                            }
                        }
                    }
                }
            }

            getActiveConnections(threshold = 0.05) {
                const connections = [];
                for (let i = 0; i < this.numNodes; i++) {
                    for (let j = 0; j < this.numNodes; j++) {
                        const weight = this.weights[i][j];
                        if (weight > threshold) {
                            connections.push({
                                source: i,
                                target: j,
                                weight: weight
                            });
                        }
                    }
                }
                return connections;
            }

            resetNodes() {
                this.nodes = Array(this.numNodes).fill(0);
            }
        }

        // –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï)
        function app() {
            return {
                isTraining: false,
                isSleeping: false,
                showHelp: false,
                speed: 3,
                connectionThreshold: 0.1,
                currentLayout: 'force',
                isDarkMode: true,
                
                network: null,
                sigmaInstance: null,
                graphData: null,
                
                inputNodes: 64,
                hiddenNodes: 56,
                outputNodes: 10,
                totalNodes: 130,
                
                trainingStep: 0,
                totalSteps: 0,
                correctPredictions: 0,
                accuracy: 0,
                mutationRate: 0.15,
                activeConnections: 0,
                
                currentSample: null,
                prediction: null,
                
                eventLog: [],
                
                async init() {
                    this.addLog('NeuroTick SPA Initializing...', 'info');
                    
                    try {
                        this.initNetwork();
                        await this.initSigma();
                        this.loadSample();
                        
                        this.initTheme();
                        
                        this.addLog('System ready. Click Start to begin training.', 'success');
                    } catch (error) {
                        console.error('Initialization error:', error);
                        this.addLog('Initialization failed: ' + error.message, 'error');
                    }
                },
                
                initTheme() {
                    const savedTheme = localStorage.getItem('neurotick-theme');
                    this.isDarkMode = savedTheme !== 'light';
                    
                    if (this.isDarkMode) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                },
                
                addLog(message, type = 'info') {
                    const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                    this.eventLog.push({
                        time,
                        message,
                        type
                    });
                    
                    if (this.eventLog.length > 50) {
                        this.eventLog = this.eventLog.slice(-50);
                    }
                },
                
                initNetwork() {
                    this.network = new NeuroTick();
                    this.addLog('NeuroTick network created', 'info');
                },
                
                loadSample() {
                    const digits = [
                        [0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,
                         1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,
                         0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,
                         0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,
                         0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,
                         1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]
                    ].map(arr => arr.map(x => x / 8.0));
                    
                    const labels = [0, 1, 2, 3, 4];
                    const idx = Math.floor(Math.random() * digits.length);
                    
                    this.currentSample = {
                        image: digits[idx],
                        label: labels[idx],
                        pixels: Array.from({length: 64}, (_, i) => ({
                            x: i % 8,
                            y: Math.floor(i / 8),
                            value: digits[idx][i]
                        }))
                    };
                },
                
                updateStats() {
                    if (this.totalSteps > 0) {
                        this.accuracy = (this.correctPredictions / this.totalSteps) * 100;
                    }
                    this.mutationRate = this.network?.mutationRate || 0.15;
                    
                    if (this.network) {
                        this.activeConnections = this.network.getActiveConnections(this.connectionThreshold).length;
                    }
                },
                
                toggleTraining() {
                    this.isTraining = !this.isTraining;
                    
                    if (this.isTraining) {
                        this.addLog('Training started', 'success');
                        this.train();
                    } else {
                        this.addLog('Training paused', 'warning');
                    }
                },
                
                resetNetwork() {
                    this.isTraining = false;
                    this.trainingStep = 0;
                    this.totalSteps = 0;
                    this.correctPredictions = 0;
                    this.initNetwork();
                    this.updateGraph();
                    this.addLog('Network reset to initial state', 'info');
                },
                
                toggleTheme() {
                    this.isDarkMode = !this.isDarkMode;
                    
                    if (this.isDarkMode) {
                        document.documentElement.classList.add('dark');
                        localStorage.setItem('neurotick-theme', 'dark');
                        this.addLog('Switched to dark theme', 'info');
                    } else {
                        document.documentElement.classList.remove('dark');
                        localStorage.setItem('neurotick-theme', 'light');
                        this.addLog('Switched to light theme', 'info');
                    }
                },
                
                exportNetwork() {
                    if (!this.network) return;
                    
                    const data = {
                        weights: this.network.weights,
                        connections: this.network.getActiveConnections(0.05),
                        statistics: {
                            accuracy: this.accuracy,
                            totalSteps: this.totalSteps,
                            mutationRate: this.mutationRate
                        },
                        timestamp: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `neurotick-export-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.addLog('Network exported', 'success');
                },
                
                async initSigma() {
                    try {
                        const container = document.getElementById('sigma-container');
                        if (!container) return;
                        
                        // –ò–°–ü–†–ê–í–õ–ï–ù–û: —Å–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ –±–µ–∑ –æ—à–∏–±–æ–∫
                        this.graphData = new graphology.Graph({allowSelfLoops: false, multi: false});
                        
                        // –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è sigma.js
                        this.sigmaInstance = new sigma({
                            graph: this.graphData,
                            container: 'sigma-container',
                            settings: {
                                defaultNodeColor: '#00ff9d',
                                defaultEdgeColor: '#00e0ff',
                                minEdgeSize: 0.5,
                                maxEdgeSize: 5,
                                labelThreshold: 8,
                                labelSize: 'proportional',
                                labelSizeRatio: 1,
                                font: 'JetBrains Mono',
                                labelColor: { color: '#ffffff' }
                            }
                        });
                        
                        // –°–æ–∑–¥–∞–µ–º —É–∑–ª—ã
                        this.createGraphNodes();
                        
                        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π layout
                        this.applyLayout('force');
                        
                        this.addLog('Sigma.js visualization initialized', 'success');
                    } catch (error) {
                        console.error('Sigma.js initialization error:', error);
                        this.addLog('Failed to initialize visualization: ' + error.message, 'error');
                    }
                },
                
                createGraphNodes() {
                    if (!this.graphData || !this.network) return;
                    
                    this.graphData.clear();
                    
                    // –°–æ–∑–¥–∞–µ–º —É–∑–ª—ã
                    for (let i = 0; i < this.network.numNodes; i++) {
                        const nodeType = this.getNodeType(i);
                        const nodeColor = this.getNodeColor(nodeType);
                        const nodeSize = this.getNodeSize(nodeType);
                        const nodeLabel = this.getNodeLabel(i, nodeType);
                        
                        this.graphData.addNode(i.toString(), {
                            label: nodeLabel,
                            size: nodeSize,
                            color: nodeColor,
                            type: nodeType,
                            x: Math.random() * 100,
                            y: Math.random() * 100
                        });
                    }
                    
                    this.addLog(`Created ${this.network.numNodes} graph nodes`, 'info');
                },
                
                getNodeType(nodeId) {
                    if (nodeId < 64) return 'input';
                    if (nodeId >= 64 && nodeId < 120) return 'hidden';
                    if (nodeId >= 120) return 'output';
                    return 'hidden';
                },
                
                getNodeColor(nodeType) {
                    switch(nodeType) {
                        case 'input': return '#00ff9d';
                        case 'hidden': return '#00e0ff';
                        case 'output': return '#9d00ff';
                        default: return '#666666';
                    }
                },
                
                getNodeSize(nodeType) {
                    switch(nodeType) {
                        case 'input': return 4;
                        case 'hidden': return 6;
                        case 'output': return 8;
                        default: return 5;
                    }
                },
                
                getNodeLabel(nodeId, nodeType) {
                    if (nodeType === 'input') return `Px${nodeId}`;
                    if (nodeType === 'output') {
                        const digit = nodeId - 120;
                        return `D${digit}`;
                    }
                    return `N${nodeId}`;
                },
                
                updateGraph() {
                    if (!this.graphData || !this.network || !this.sigmaInstance) return;
                    
                    const connections = this.network.getActiveConnections(this.connectionThreshold);
                    
                    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ä–µ–±—Ä–∞
                    const edges = this.graphData.edges();
                    edges.forEach(edge => this.graphData.dropEdge(edge));
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Ä–µ–±—Ä–∞
                    connections.forEach(conn => {
                        try {
                            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ ID
                            this.graphData.addEdge(
                                conn.source.toString(), 
                                conn.target.toString(), 
                                {
                                    size: Math.max(conn.weight * 3, 0.5),
                                    color: this.getEdgeColor(conn.weight)
                                }
                            );
                        } catch (error) {
                            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–±–µ—Ä
                        }
                    });
                    
                    this.activeConnections = connections.length;
                    this.sigmaInstance.refresh();
                },
                
                getEdgeColor(weight) {
                    if (weight > 0.3) return '#ffd600';
                    if (weight > 0.2) return '#00ff9d';
                    if (weight > 0.1) return '#00e0ff';
                    return '#9d00ff';
                },
                
                toggleLayout() {
                    if (!this.graphData || !this.sigmaInstance) return;
                    
                    const layouts = ['force', 'circular', 'random'];
                    const currentIndex = layouts.indexOf(this.currentLayout);
                    const nextLayout = layouts[(currentIndex + 1) % layouts.length];
                    this.currentLayout = nextLayout;
                    
                    this.applyLayout(nextLayout);
                    this.addLog(`Changed layout to ${nextLayout}`, 'info');
                },
                
                applyLayout(layoutType) {
                    if (!this.graphData) return;
                    
                    switch(layoutType) {
                        case 'force':
                            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º ForceAtlas2 –∏–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
                            if (typeof window.forceAtlas2 === 'function') {
                                const positions = window.forceAtlas2(this.graphData, {
                                    settings: {
                                        gravity: 0.5,
                                        scalingRatio: 30,
                                        slowDown: 10,
                                        barnesHutOptimize: true,
                                        barnesHutTheta: 0.8,
                                        adjustSizes: true,
                                        linLogMode: false,
                                        outboundAttractionDistribution: false
                                    },
                                    iterations: 50
                                });
                                
                                // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏–∏
                                Object.keys(positions).forEach(nodeId => {
                                    this.graphData.mergeNodeAttributes(nodeId, positions[nodeId]);
                                });
                                
                                if (this.sigmaInstance) this.sigmaInstance.refresh();
                            } else {
                                // Fallback: —Å–ª—É—á–∞–π–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                                this.graphData.forEachNode(node => {
                                    this.graphData.mergeNodeAttributes(node, {
                                        x: Math.random() * 200 - 100,
                                        y: Math.random() * 200 - 100
                                    });
                                });
                                if (this.sigmaInstance) this.sigmaInstance.refresh();
                            }
                            break;
                            
                        case 'circular':
                            const nodes = this.graphData.nodes();
                            const radius = 100;
                            nodes.forEach((node, index) => {
                                const angle = (index / nodes.length) * Math.PI * 2;
                                this.graphData.mergeNodeAttributes(node, {
                                    x: Math.cos(angle) * radius,
                                    y: Math.sin(angle) * radius
                                });
                            });
                            if (this.sigmaInstance) this.sigmaInstance.refresh();
                            break;
                            
                        case 'random':
                            this.graphData.forEachNode(node => {
                                this.graphData.mergeNodeAttributes(node, {
                                    x: Math.random() * 200 - 100,
                                    y: Math.random() * 200 - 100
                                });
                            });
                            if (this.sigmaInstance) this.sigmaInstance.refresh();
                            break;
                    }
                },
                
                resetView() {
                    if (this.sigmaInstance) {
                        const camera = this.sigmaInstance.getCamera();
                        camera.animate({
                            x: 0,
                            y: 0,
                            ratio: 1
                        }, {
                            duration: 500
                        });
                    }
                    this.addLog('Graph view reset', 'info');
                },
                
                async train() {
                    if (!this.isTraining) return;
                    
                    while (this.isTraining && this.trainingStep < 3000) {
                        this.isSleeping = (this.trainingStep % 1000) > 800;
                        
                        if (this.trainingStep % 10 === 0) {
                            this.loadSample();
                        }
                        
                        this.network.resetNodes();
                        
                        for (let tick = 0; tick < 15; tick++) {
                            const inputs = {};
                            this.currentSample.image.forEach((val, idx) => {
                                inputs[idx] = val;
                            });
                            
                            this.prediction = this.network.tick(
                                inputs,
                                this.currentSample.label,
                                this.isSleeping
                            );
                        }
                        
                        this.totalSteps++;
                        if (this.prediction.isCorrect) {
                            this.correctPredictions++;
                        }
                        
                        this.updateStats();
                        
                        if (this.trainingStep % 50 === 0) {
                            this.updateGraph();
                        }
                        
                        if (this.trainingStep % 100 === 0) {
                            this.addLog(`Step ${this.trainingStep}: Accuracy ${this.accuracy.toFixed(1)}%`, 'info');
                        }
                        
                        this.trainingStep++;
                        await this.sleep(100 / this.speed);
                    }
                    
                    if (this.trainingStep >= 3000) {
                        this.addLog('Training completed!', 'success');
                        this.isTraining = false;
                    }
                },
                
                sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }
            };
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', function() {
            document.addEventListener('keydown', function(e) {
                const appInstance = Alpine.$data(document.querySelector('[x-data]'));
                if (!appInstance) return;
                
                if (e.key === ' ') {
                    appInstance.toggleTraining();
                    e.preventDefault();
                }
                
                if (e.key === 'r' && e.ctrlKey) {
                    appInstance.resetNetwork();
                    e.preventDefault();
                }
                
                if (e.key === 'h' && e.ctrlKey) {
                    appInstance.showHelp = true;
                    e.preventDefault();
                }
                
                if (e.key === 'Escape') {
                    if (appInstance.showHelp) {
                        appInstance.showHelp = false;
                    }
                }
            });
        });
    </script>
</body>
</html>
