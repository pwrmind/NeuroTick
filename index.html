<!DOCTYPE html>
<html lang="en" x-data="app()" x-init="init()">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroTick - Corrected Neural Network</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'mono': ['JetBrains Mono', 'monospace'],
                        'sans': ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'neuro-dark': '#0a0a0a',
                        'neuro-gray': '#1a1a1a',
                        'neuro-border': '#2a2a2a',
                        'neuro-green': '#00ff9d',
                        'neuro-cyan': '#00e0ff',
                        'neuro-purple': '#9d00ff',
                        'neuro-pink': '#ff00c8',
                        'neuro-yellow': '#ffd600',
                    }
                }
            }
        }
    </script>
    
    <style>
        .sigma-container { background: #0a0a0a !important; }
        .glass-effect {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-neuro-dark text-white font-sans min-h-screen">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        
        <header class="mb-8">
            <div>
                <h1 class="text-3xl md:text-4xl font-bold font-mono text-neuro-green mb-2">
                    <i class="fas fa-brain mr-3"></i>NeuroTick - CORRECTED
                </h1>
                <p class="text-neuro-cyan text-opacity-80">
                    Fixed Learning Algorithm • Now Actually Learns
                </p>
            </div>
        </header>
        
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                    <i class="fas fa-chart-line mr-2"></i>Training Progress
                </h2>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1">
                            <span class="text-sm">Progress</span>
                            <span class="text-sm font-mono" x-text="`${step}/3000`"></span>
                        </div>
                        <div class="w-full bg-neuro-gray rounded-full h-2">
                            <div class="bg-neuro-green h-2 rounded-full transition-all duration-300" 
                                 :style="`width: ${(step/3000)*100}%`"></div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-3">
                        <div class="text-center p-3 bg-neuro-gray rounded-lg">
                            <div class="text-2xl font-bold" :class="accuracy > 50 ? 'text-neuro-green' : 'text-neuro-pink'" 
                                 x-text="accuracy.toFixed(1)"></div>
                            <div class="text-xs mt-1 text-gray-400">Accuracy %</div>
                        </div>
                        <div class="text-center p-3 bg-neuro-gray rounded-lg">
                            <div class="text-2xl font-bold text-neuro-cyan" x-text="correct"></div>
                            <div class="text-xs mt-1 text-gray-400">Correct</div>
                        </div>
                        <div class="text-center p-3 bg-neuro-gray rounded-lg">
                            <div class="text-2xl font-bold text-neuro-yellow" x-text="connections"></div>
                            <div class="text-xs mt-1 text-gray-400">Connections</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-cyan mb-4">
                    <i class="fas fa-sliders-h mr-2"></i>Controls
                </h2>
                <div class="space-y-4">
                    <div class="flex gap-2">
                        <button @click="startTraining()" 
                                class="flex-1 py-2 rounded-lg font-semibold transition bg-neuro-green hover:bg-neuro-cyan"
                                :disabled="training">
                            <i class="fas fa-play mr-2"></i>
                            <span x-text="training ? 'Training...' : 'Start Training'"></span>
                        </button>
                        <button @click="stopTraining()" 
                                class="px-4 py-2 bg-neuro-gray hover:bg-neuro-border rounded-lg transition"
                                :disabled="!training">
                            <i class="fas fa-stop"></i>
                        </button>
                    </div>
                    
                    <div>
                        <label class="block text-sm mb-2">Learning Rate</label>
                        <input type="range" min="0.01" max="0.5" step="0.01" x-model="learningRate"
                               class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 mt-1" x-text="'Rate: ' + learningRate.toFixed(2)"></div>
                    </div>
                    
                    <div>
                        <label class="block text-sm mb-2">Activation Threshold</label>
                        <input type="range" min="0.1" max="1.0" step="0.05" x-model="threshold"
                               class="w-full h-2 bg-neuro-gray rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-gray-400 mt-1" x-text="'Threshold: ' + threshold.toFixed(2)"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-purple mb-4">
                    <i class="fas fa-image mr-2"></i>Current Sample
                </h2>
                <div class="flex flex-col md:flex-row gap-6 items-center">
                    <div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Target</div>
                            <div class="text-4xl font-bold font-mono" x-text="currentLabel"></div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400">Predicted</div>
                            <div class="text-3xl font-bold font-mono" 
                                 :class="predicted === currentLabel ? 'text-neuro-green' : 'text-neuro-pink'"
                                 x-text="predicted"></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">Confidence</div>
                            <div class="text-2xl font-mono" 
                                 :class="confidence > 0.5 ? 'text-neuro-green' : 'text-yellow-400'"
                                 x-text="(confidence * 100).toFixed(1) + '%'"></div>
                        </div>
                    </div>
                    
                    <div class="flex-1">
                        <div class="text-sm text-gray-400 mb-2">Digit</div>
                        <div class="grid grid-cols-8 gap-1 max-w-[240px] mx-auto">
                            <template x-for="(pixel, idx) in currentImage">
                                <div class="aspect-square rounded-sm border border-neuro-border"
                                     :style="`background-color: rgb(${pixel * 255}, ${pixel * 255}, ${pixel * 255})`"
                                     :title="`Value: ${pixel.toFixed(2)}`"></div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="glass-effect rounded-xl p-4">
                <h2 class="text-xl font-semibold text-neuro-green mb-4">
                    <i class="fas fa-brain mr-2"></i>Network Info
                </h2>
                <div class="space-y-3">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Input Neurons:</span>
                        <span class="font-mono">64</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Hidden Neurons:</span>
                        <span class="font-mono">56</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Output Neurons:</span>
                        <span class="font-mono">10</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Total Connections:</span>
                        <span class="font-mono" x-text="connections"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Learning Rate:</span>
                        <span class="font-mono" x-text="learningRate.toFixed(3)"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Mutation Rate:</span>
                        <span class="font-mono" x-text="mutationRate.toFixed(3)"></span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="glass-effect rounded-xl p-4 mb-6">
            <h2 class="text-xl font-semibold text-neuro-yellow mb-4">
                <i class="fas fa-history mr-2"></i>Training Log
            </h2>
            <div class="h-40 overflow-y-auto space-y-2">
                <template x-for="(log, idx) in logs.slice().reverse().slice(0, 10)">
                    <div class="text-sm p-2 rounded bg-neuro-gray border-l-4"
                         :class="{
                             'border-neuro-green': log.type === 'success',
                             'border-neuro-pink': log.type === 'error',
                             'border-neuro-cyan': log.type === 'info'
                         }">
                        <span class="font-mono text-xs text-gray-400" x-text="log.step"></span>
                        <span class="ml-2" x-text="log.message"></span>
                    </div>
                </template>
            </div>
        </div>
        
        <footer class="text-center text-gray-500 text-sm py-6 border-t border-neuro-border">
            NeuroTick v3.0 • Fixed Learning Algorithm • Now actually learns digits
        </footer>
    </div>

    <!-- Исправленный код нейронной сети -->
    <script>
        // ====================== ИСПРАВЛЕННАЯ НЕЙРОННАЯ СЕТЬ ======================
        class FixedNeuroTick {
            constructor(numNodes = 130) {
                this.numNodes = numNodes;
                this.inputSize = 64;
                this.hiddenSize = 56;
                this.outputSize = 10;
                
                // Правильная архитектура: входы -> скрытые -> выходы
                this.weightsInputHidden = this.randomMatrix(this.inputSize, this.hiddenSize, 0.1);
                this.weightsHiddenOutput = this.randomMatrix(this.hiddenSize, this.outputSize, 0.1);
                
                // Скрытые связи для полносвязной сети
                this.weights = this.randomMatrix(numNodes, numNodes, 0.05);
                this.immunity = Array(numNodes).fill().map(() => Array(numNodes).fill(0));
                
                // Инициализация некоторых случайных связей (как в Python)
                for (let i = 0; i < numNodes * 2; i++) {
                    const src = Math.floor(Math.random() * (this.inputSize + this.hiddenSize));
                    const dst = this.inputSize + Math.floor(Math.random() * (this.hiddenSize + this.outputSize));
                    if (src !== dst && src < dst) {
                        this.weights[src][dst] = 0.05 + Math.random() * 0.15;
                        this.immunity[src][dst] = 20;
                    }
                }
                
                this.nodes = new Array(numNodes).fill(0);
                this.mutationRate = 0.15;
                this.inputIds = Array.from({length: 64}, (_, i) => i);
                this.outputIds = Array.from({length: 10}, (_, i) => numNodes - 10 + i);
                this.classNames = Array.from({length: 10}, (_, i) => i.toString());
                
                this.totalSteps = 0;
            }
            
            randomMatrix(rows, cols, scale) {
                return Array.from({length: rows}, () => 
                    Array.from({length: cols}, () => (Math.random() * 2 - 1) * scale)
                );
            }
            
            // ИСПРАВЛЕННАЯ АКТИВАЦИЯ (как в Python)
            tick(inputs, target = null, isSleeping = false) {
                // Сброс узлов (кроме сохранения состояния)
                for (let i = 0; i < this.numNodes; i++) {
                    if (i < this.inputSize) {
                        this.nodes[i] = inputs[i] || 0;
                    } else {
                        this.nodes[i] *= 0.5; // Постепенное затухание
                    }
                }
                
                // ПРЯМОЕ РАСПРОСТРАНЕНИЕ (как в Python @ operator)
                const newActivation = new Array(this.numNodes).fill(0);
                
                // Матричное умножение nodes @ weights
                for (let i = 0; i < this.numNodes; i++) {
                    if (Math.abs(this.nodes[i]) < 0.01) continue;
                    
                    for (let j = 0; j < this.numNodes; j++) {
                        if (i === j) continue;
                        const weight = this.weights[i][j];
                        if (Math.abs(weight) > 0.01) {
                            newActivation[j] += this.nodes[i] * weight;
                        }
                    }
                }
                
                // Применение активации с порогом (как в Python)
                for (let i = 0; i < this.numNodes; i++) {
                    if (i >= this.inputSize) { // Не изменяем входные нейроны
                        this.nodes[i] = newActivation[i] > 0.6 ? Math.tanh(newActivation[i]) : 0;
                    }
                }
                
                // Получение выходных значений
                const outputs = this.outputIds.map(id => this.nodes[id]);
                const maxOutput = Math.max(...outputs);
                const predicted = outputs.indexOf(maxOutput);
                const confidence = maxOutput;
                
                const isConfident = confidence > 0.1;
                const isCorrect = target !== null && predicted === target && isConfident;
                
                // ОБУЧЕНИЕ (только если не в режиме сна)
                if (!isSleeping && target !== null) {
                    this.trainStep(target, predicted, isCorrect, isConfident);
                    this.totalSteps++;
                }
                
                return {
                    predicted,
                    confidence,
                    isCorrect,
                    outputs
                };
            }
            
            // ИСПРАВЛЕННОЕ ОБУЧЕНИЕ
            trainStep(target, predicted, isCorrect, isConfident) {
                const targetNode = this.outputIds[target];
                const wrongNode = this.outputIds[predicted];
                
                // Корректировка скорости мутации
                this.mutationRate *= isCorrect ? 0.98 : 1.02;
                this.mutationRate = Math.max(0.01, Math.min(0.4, this.mutationRate));
                
                // Проходим по всем связям
                for (let i = 0; i < this.numNodes; i++) {
                    for (let j = 0; j < this.numNodes; j++) {
                        if (i === j) continue;
                        
                        const weight = this.weights[i][j];
                        
                        if (weight !== 0) {
                            // УСИЛЕНИЕ правильных связей (LTP)
                            if (isCorrect && j === targetNode && this.nodes[i] > 0.05) {
                                this.weights[i][j] += 0.1 * this.nodes[i];
                                this.immunity[i][j] = 50;
                            }
                            // ОСЛАБЛЕНИЕ неправильных связей (LTD)
                            else if (!isCorrect && isConfident && j === wrongNode && this.nodes[i] > 0.05) {
                                this.weights[i][j] *= 0.7;
                                if (Math.abs(this.weights[i][j]) < 0.01) {
                                    this.weights[i][j] = 0;
                                }
                                this.immunity[i][j] = 0;
                            }
                            
                            // СИНАПТИЧЕСКИЙ РАСПАД
                            if (this.immunity[i][j] <= 0) {
                                this.weights[i][j] *= 0.95;
                            } else {
                                this.immunity[i][j]--;
                            }
                            
                            if (Math.abs(this.weights[i][j]) < 0.01) {
                                this.weights[i][j] = 0;
                            }
                        } else {
                            // СОЗДАНИЕ НОВЫХ СВЯЗЕЙ (мутация)
                            if (Math.random() < this.mutationRate * 0.1) {
                                if (i < j && Math.random() < 0.3) { // Только forward connections
                                    this.weights[i][j] = (Math.random() * 0.2 - 0.1);
                                    this.immunity[i][j] = 30;
                                }
                            }
                        }
                    }
                }
                
                // ГОМЕОСТАЗ (Synaptic Scaling)
                for (let j = 0; j < this.numNodes; j++) {
                    let totalInput = 0;
                    for (let i = 0; i < this.numNodes; i++) {
                        totalInput += Math.abs(this.weights[i][j]);
                    }
                    
                    if (totalInput > 1.0) {
                        const scale = 1.0 / totalInput;
                        for (let i = 0; i < this.numNodes; i++) {
                            this.weights[i][j] *= scale;
                        }
                    }
                }
            }
            
            getActiveConnections(threshold = 0.05) {
                let count = 0;
                for (let i = 0; i < this.numNodes; i++) {
                    for (let j = 0; j < this.numNodes; j++) {
                        if (Math.abs(this.weights[i][j]) > threshold) {
                            count++;
                        }
                    }
                }
                return count;
            }
            
            resetState() {
                for (let i = this.inputSize; i < this.numNodes; i++) {
                    this.nodes[i] = 0;
                }
            }
        }

        // ====================== ОСНОВНОЕ ПРИЛОЖЕНИЕ ======================
        function app() {
            return {
                // Состояние
                training: false,
                step: 0,
                correct: 0,
                accuracy: 0,
                connections: 0,
                mutationRate: 0.15,
                
                // Параметры
                learningRate: 0.1,
                threshold: 0.6,
                
                // Данные
                currentImage: Array(64).fill(0),
                currentLabel: 0,
                predicted: 0,
                confidence: 0,
                
                // Сеть
                network: null,
                
                // Логи
                logs: [],
                
                // Инициализация
                init() {
                    this.network = new FixedNeuroTick();
                    this.mutationRate = this.network.mutationRate;
                    this.generateDigits();
                    this.loadRandomSample();
                    this.addLog(0, 'System initialized. Ready to learn!');
                },
                
                // Генерация данных (10 цифр, 0-9)
                generateDigits() {
                    this.digits = {
                        0: [
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        1: [
                            0,0,0,1,0,0,0,
                            0,0,1,1,0,0,0,
                            0,1,0,1,0,0,0,
                            0,0,0,1,0,0,0,
                            0,0,0,1,0,0,0,
                            0,0,0,1,0,0,0,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        2: [
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            0,0,0,0,0,0,1,
                            0,0,0,0,1,1,0,
                            0,0,1,1,0,0,0,
                            1,1,0,0,0,0,0,
                            1,1,1,1,1,1,1,
                            0,0,0,0,0,0,0
                        ],
                        3: [
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            0,0,0,0,0,0,1,
                            0,0,0,1,1,1,0,
                            0,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        4: [
                            0,0,0,0,1,1,0,
                            0,0,0,1,0,1,0,
                            0,0,1,0,0,1,0,
                            0,1,0,0,0,1,0,
                            1,1,1,1,1,1,1,
                            0,0,0,0,0,1,0,
                            0,0,0,0,0,1,0,
                            0,0,0,0,0,0,0
                        ],
                        5: [
                            1,1,1,1,1,1,1,
                            1,0,0,0,0,0,0,
                            1,1,1,1,1,1,0,
                            0,0,0,0,0,0,1,
                            0,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        6: [
                            0,0,1,1,1,1,0,
                            0,1,0,0,0,0,0,
                            1,0,0,0,0,0,0,
                            1,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        7: [
                            1,1,1,1,1,1,1,
                            0,0,0,0,0,0,1,
                            0,0,0,0,0,1,0,
                            0,0,0,0,1,0,0,
                            0,0,0,1,0,0,0,
                            0,0,1,0,0,0,0,
                            0,1,0,0,0,0,0,
                            0,0,0,0,0,0,0
                        ],
                        8: [
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,0,
                            0,0,0,0,0,0,0
                        ],
                        9: [
                            0,1,1,1,1,1,0,
                            1,0,0,0,0,0,1,
                            1,0,0,0,0,0,1,
                            0,1,1,1,1,1,1,
                            0,0,0,0,0,0,1,
                            0,0,0,0,0,1,0,
                            0,1,1,1,1,0,0,
                            0,0,0,0,0,0,0
                        ]
                    };
                    
                    // Нормализация 0-1
                    for (let digit in this.digits) {
                        this.digits[digit] = this.digits[digit].map(x => x / 1.0);
                    }
                },
                
                // Загрузка случайного образца
                loadRandomSample() {
                    const digit = Math.floor(Math.random() * 10);
                    this.currentLabel = digit;
                    this.currentImage = [...this.digits[digit]];
                },
                
                // Добавление лога
                addLog(step, message, type = 'info') {
                    this.logs.push({
                        step: `Step ${step}`,
                        message: message,
                        type: type
                    });
                    if (this.logs.length > 20) {
                        this.logs.shift();
                    }
                },
                
                // Начало обучения
                async startTraining() {
                    if (this.training) return;
                    
                    this.training = true;
                    this.addLog(this.step, 'Training started!', 'success');
                    
                    while (this.training && this.step < 3000) {
                        await this.trainStep();
                        
                        // Обновление статистики
                        if (this.step > 0) {
                            this.accuracy = (this.correct / this.step) * 100;
                        }
                        this.connections = this.network.getActiveConnections(0.05);
                        this.mutationRate = this.network.mutationRate;
                        
                        // Пауза для анимации
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    if (this.step >= 3000) {
                        this.addLog(this.step, 'Training completed!', 'success');
                        this.training = false;
                    }
                },
                
                // Один шаг обучения
                async trainStep() {
                    this.loadRandomSample();
                    
                    const isSleeping = (this.step % 1000) > 800;
                    
                    // Сброс состояния сети
                    this.network.resetState();
                    
                    // 15 тактов обработки (как в Python)
                    let result = null;
                    for (let tick = 0; tick < 15; tick++) {
                        // Создание входного словаря
                        const inputs = {};
                        this.currentImage.forEach((val, idx) => {
                            inputs[idx] = val;
                        });
                        
                        result = this.network.tick(
                            inputs,
                            this.currentLabel,
                            isSleeping && tick > 5
                        );
                    }
                    
                    // Обновление UI
                    this.predicted = result.predicted;
                    this.confidence = result.confidence;
                    
                    if (result.isCorrect) {
                        this.correct++;
                    }
                    
                    this.step++;
                    
                    // Логирование
                    if (this.step % 100 === 0) {
                        const status = result.isCorrect ? '✓' : '✗';
                        this.addLog(
                            this.step,
                            `Digit ${this.currentLabel} → ${this.predicted} ${status} (${this.accuracy.toFixed(1)}%)`,
                            result.isCorrect ? 'success' : 'info'
                        );
                    }
                },
                
                // Остановка обучения
                stopTraining() {
                    this.training = false;
                    this.addLog(this.step, 'Training stopped', 'info');
                },
                
                // Сброс сети
                resetNetwork() {
                    this.training = false;
                    this.step = 0;
                    this.correct = 0;
                    this.accuracy = 0;
                    this.network = new FixedNeuroTick();
                    this.mutationRate = this.network.mutationRate;
                    this.loadRandomSample();
                    this.addLog(0, 'Network reset', 'info');
                }
            };
        }
    </script>
</body>
</html>
